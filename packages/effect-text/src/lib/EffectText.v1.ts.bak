import type { IJSONOptions } from '@leafer-in/interface'

import type {
  IObject,
  IPaint,
  IPointData,
  IStrokePaint,
  ITextStyleAttrData,
  ITextStyleComputedData,
  ITextStyleInputData,
  IUI,
  IUIBaseInputData,
  IUIData,
} from '@leafer-ui/interface'
import {
  boundsType,
  dataProcessor,
  registerUI,
  Text,
  TextData,
} from '@leafer-ui/core'

type IEnable<T> = T & {
  visible: boolean
}

type ITextEffect = IEnable<{
  enable?: boolean
  offset?: IEnable<IPointData>
  stroke?: IEnable<IStrokePaint>
  fill?: IEnable<IPaint>
}>

interface IEffectTextAttrData {
  textEffects?: ITextEffect[]
}

interface IEffectTextData extends ITextStyleComputedData, IUIData {
  __textEffects?: ITextEffect[]
}

interface IEffectText extends IEffectTextAttrData, ITextStyleAttrData, IUI {
  __: IEffectTextData
}

interface IEffectTextInputData extends IEffectTextAttrData, ITextStyleInputData, IUIBaseInputData {
  textEffects?: ITextEffect[]
}

class EffectTextData extends TextData implements IEffectTextData {
  __textEffects?: ITextEffect[]

  setTextEffects(value: ITextEffect[]) {
    const ui = this.__leaf as IEffectText
    const fills = value.map(v => v.fill).filter(Boolean)
    const strokes = value.map(v => v.stroke).filter(Boolean)
    ui.fill = fills
    ui.stroke = strokes
    this.__textEffects = value
  }

  public __getInputData(names?: string[] | IObject, options?: IJSONOptions): IObject {
    const data = super.__getInputData(names, options)
    data.textEffects = this.__textEffects
    delete data.fill
    delete data.stroke
    return data
  }
}

@registerUI()
export class EffectText<TConstructorData = IEffectTextInputData> extends Text<TConstructorData> implements IEffectText {
  get __tag() {
    return 'EffectText'
  }

  @dataProcessor(EffectTextData)
  public __: IEffectTextData

  @boundsType([])
  textEffects?: ITextEffect[]

  constructor(data?: TConstructorData) {
    super(data)
  }
}
